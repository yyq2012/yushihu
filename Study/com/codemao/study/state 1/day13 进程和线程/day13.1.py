# 进程和线程
#
# 今天我们使用的计算机早已进入多CPU或多核时代，
# 而我们使用的操作系统都是支持“多任务”的操作系统，
# 这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，
# 让多个子任务并发的执行，从而缩短程序的执行时间，
# 同时也让用户获得更好的体验。
# 因此在当下不管是用什么编程语言进行开发，
# 实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。
# 为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。
#
# ### 概念
#
# 进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，
# 每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，
# 操作系统管理所有进程的执行，为它们合理的分配资源。
# 进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，
# 不过新的进程也有自己独立的内存空间，
# 因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，
# 具体的方式包括管道、信号、套接字、共享内存区等。
#
# 一个进程还可以拥有多个并发的执行线索，
# 简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。
# 由于线程在同一个进程下，它们可以共享相同的上下文，
# 因此相对于进程而言，线程间的信息共享和通信更加容易。
# 当然在单核CPU系统中，真正的并发是不可能的，
# 因为在某个时刻能够获得CPU的只有唯一的一个线程，
# 多个线程共享了CPU的执行时间。
# 使用多线程实现并发编程为程序带来的好处是不言而喻的，
# 最主要的体现在提升程序的性能和改善用户体验，
# 今天我们使用的软件几乎都用到了多线程技术，
#
# 当然多线程也并不是没有坏处，站在其他进程的角度，
# 多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，
# 导致其他程序无法获得足够的CPU执行时间；
# 另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，
# 对于初学者来说更加困难。
#
# Python既支持多进程又支持多线程，
# 因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。
#
# ### Python中的多进程
#
# Unix和Linux操作系统上提供了`fork()`系统调用来创建进程，
# 调用`fork()`函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，
# 但是子进程拥有自己的PID。`fork()`函数非常特殊它会返回两次，
# 父进程中可以通过`fork()`函数的返回值得到子进程的PID，
# 而子进程中的返回值永远都是0。
# Python的os模块提供了`fork()`函数。
# 由于Windows系统没有`fork()`调用，因此要实现跨平台的多进程编程，
# 可以使用multiprocessing模块的`Process`类来创建子进程，
# 而且该模块还提供了更高级的封装，
# 例如批量启动进程的进程池（`Pool`）、
# 用于进程间通信的队列（`Queue`）和管道（`Pipe`）等。
#
# 下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。
from random import randint
from time import sleep, time


def download_tast(filename):
    print('开始下载%s...' % filename)
    time_to_download = randint(5, 10)
    sleep(time_to_download)
    print('%s下载完成!耗时%d秒 ' % (filename, time_to_download))


def main():
    start = time()
    download_tast('Python从入门到住院.pdf')
    download_tast('从删库到跑路.pdf')
    end = time()
    print('总耗时为: %.2f秒' % (end - start))


if __name__ == '__main__':
    main()